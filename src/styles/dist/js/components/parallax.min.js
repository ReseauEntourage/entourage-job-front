/*! UIkit 3.6.22 | https://www.getuikit.com | (c) 2014 - 2023 YOOtheme | MIT License */
!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? (module.exports = e(require('uikit-util')))
    : 'function' == typeof define && define.amd
      ? define('uikitparallax', ['uikit-util'], e)
      : ((t =
          'undefined' != typeof globalThis
            ? globalThis
            : t || self).UIkitParallax = e(t.UIkit.util));
})(this, function (m) {
  'use strict';
  var t = {
    props: { media: Boolean },
    data: { media: !1 },
    computed: {
      matchMedia: function () {
        var t = (function (t) {
          if (m.isString(t))
            if ('@' === t[0]) {
              var e = 'breakpoint-' + t.substr(1);
              t = m.toFloat(m.getCssVar(e));
            } else if (isNaN(t)) return t;
          return !(!t || isNaN(t)) && '(min-width: ' + t + 'px)';
        })(this.media);
        return !t || window.matchMedia(t).matches;
      },
    },
  };
  m.memoize(function (r) {
    return new m.Promise(function (e, t) {
      r
        ? m.startsWith(r, 'data:')
          ? e(decodeURIComponent(r.split(',')[1]))
          : m.ajax(r).then(
              function (t) {
                return e(t.response);
              },
              function () {
                return t('SVG not found.');
              }
            )
        : t();
    });
  });
  var e = [
    'x',
    'y',
    'bgx',
    'bgy',
    'rotate',
    'scale',
    'color',
    'backgroundColor',
    'borderColor',
    'opacity',
    'blur',
    'hue',
    'grayscale',
    'invert',
    'saturate',
    'sepia',
    'fopacity',
    'stroke',
  ];
  function b(t, e) {
    var r = t.length - 1,
      i = Math.min(Math.floor(r * e), r - 1),
      t = t.slice(i, i + 2);
    return t.push(1 === e ? 1 : (e % (1 / r)) * r), t;
  }
  t = {
    mixins: [
      {
        mixins: [t],
        props: e.reduce(function (t, e) {
          return (t[e] = 'list'), t;
        }, {}),
        data: e.reduce(function (t, e) {
          return (t[e] = void 0), t;
        }, {}),
        computed: {
          props: function (f, h) {
            var g = this;
            return e.reduce(function (t, e) {
              if (!m.isUndefined(f[e])) {
                var r,
                  i,
                  a,
                  n,
                  s,
                  o,
                  c,
                  u = e.match(/color/i),
                  l = u || 'opacity' === e,
                  d = f[e].slice(),
                  l =
                    (l && m.css(h, e, ''),
                    d.length < 2 &&
                      d.unshift(('scale' === e ? 1 : l ? m.css(h, e) : 0) || 0),
                    d.reduce(function (t, e) {
                      return (
                        (m.isString(e) && e.replace(/-|\d/g, '').trim()) || t
                      );
                    }, ''));
                if (
                  (u
                    ? ((u = h.style.color),
                      (d = d.map(function (t) {
                        return m
                          .css(m.css(h, 'color', t), 'color')
                          .split(/[(),]/g)
                          .slice(1, -1)
                          .concat(1)
                          .slice(0, 4)
                          .map(m.toFloat);
                      })),
                      (h.style.color = u))
                    : m.startsWith(e, 'bg')
                      ? ((a = 'bgy' === e ? 'height' : 'width'),
                        (d = d.map(function (t) {
                          return m.toPx(t, a, g.$el);
                        })),
                        m.css(h, 'background-position-' + e[2], ''),
                        (i = m.css(h, 'backgroundPosition').split(' ')[
                          'x' === e[2] ? 0 : 1
                        ]),
                        (r = g.covers
                          ? ((n = Math.min.apply(Math, d)),
                            (s = Math.max.apply(Math, d)),
                            (o = d.indexOf(n) < d.indexOf(s)),
                            (c = s - n),
                            (d = d.map(function (t) {
                              return t - (o ? n : s);
                            })),
                            (o ? -c : 0) + 'px')
                          : i))
                      : (d = d.map(m.toFloat)),
                  'stroke' === e)
                ) {
                  if (
                    !d.some(function (t) {
                      return t;
                    })
                  )
                    return t;
                  u = g.$el;
                  var p = Math.ceil(
                    Math.max.apply(
                      Math,
                      [0].concat(
                        m.$$('[stroke]', u).map(function (t) {
                          try {
                            return t.getTotalLength();
                          } catch (t) {
                            return 0;
                          }
                        })
                      )
                    )
                  );
                  m.css(h, 'strokeDasharray', p),
                    (d = (d =
                      '%' === l
                        ? d.map(function (t) {
                            return (t * p) / 100;
                          })
                        : d).reverse()),
                    (e = 'strokeDashoffset');
                }
                t[e] = { steps: d, unit: l, pos: r, bgPos: i, diff: c };
              }
              return t;
            }, {});
          },
          bgProps: function () {
            var e = this;
            return ['bgx', 'bgy'].filter(function (t) {
              return t in e.props;
            });
          },
          covers: function (t, e) {
            return (
              (r = (e = e).style.backgroundSize),
              (i =
                'cover' ===
                m.css(m.css(e, 'backgroundSize', ''), 'backgroundSize')),
              (e.style.backgroundSize = r),
              i
            );
            var r, i;
          },
        },
        disconnected: function () {
          delete this._image;
        },
        update: {
          read: function (t) {
            var e,
              r,
              o,
              c,
              u,
              l = this;
            this.matchMedia &&
              (!t.image &&
                this.covers &&
                this.bgProps.length &&
                (r = m
                  .css(this.$el, 'backgroundImage')
                  .replace(/^none|url\(["']?(.+?)["']?\)$/, '$1')) &&
                (((e = new Image()).src = r),
                (t.image = e).naturalWidth ||
                  (e.onload = function () {
                    return l.$update();
                  })),
              (r = t.image)) &&
              r.naturalWidth &&
              ((o = {
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
              }),
              (c = { width: r.naturalWidth, height: r.naturalHeight }),
              (u = m.Dimensions.cover(c, o)),
              this.bgProps.forEach(function (t) {
                var e,
                  r = l.props[t],
                  i = r.diff,
                  a = r.bgPos,
                  r = r.steps,
                  n = 'bgy' === t ? 'height' : 'width',
                  s = u[n] - o[n];
                s < i
                  ? (o[n] = u[n] + i - s)
                  : i < s &&
                    (e = o[n] / m.toPx(a, n, l.$el)) &&
                    (l.props[t].steps = r.map(function (t) {
                      return t - (s - i) / e;
                    })),
                  (u = m.Dimensions.cover(c, o));
              }),
              (t.dim = u));
          },
          write: function (t) {
            t = t.dim;
            this.matchMedia
              ? t &&
                m.css(this.$el, {
                  backgroundSize: t.width + 'px ' + t.height + 'px',
                  backgroundRepeat: 'no-repeat',
                })
              : m.css(this.$el, { backgroundSize: '', backgroundRepeat: '' });
          },
          events: ['resize'],
        },
        methods: {
          reset: function () {
            var r = this;
            m.each(this.getCss(0), function (t, e) {
              return m.css(r.$el, e, '');
            });
          },
          getCss: function (h) {
            var g = this.props;
            return Object.keys(g).reduce(
              function (t, e) {
                var r,
                  i,
                  a,
                  n = g[e],
                  s = n.steps,
                  o = n.unit,
                  c = n.pos,
                  u =
                    (void 0 === i && (i = 2),
                    (r = (n = b((n = s), (r = h)))[0]),
                    (a = n[1]),
                    (n = n[2]),
                    (m.isNumber(r)
                      ? r + Math.abs(r - a) * n * (r < a ? 1 : -1)
                      : +a
                    ).toFixed(i));
                switch (e) {
                  case 'x':
                  case 'y':
                    (o = o || 'px'),
                      (t.transform +=
                        ' translate' +
                        m.ucfirst(e) +
                        '(' +
                        m.toFloat(u).toFixed('px' === o ? 0 : 2) +
                        o +
                        ')');
                    break;
                  case 'rotate':
                    t.transform += ' rotate(' + (u + (o = o || 'deg')) + ')';
                    break;
                  case 'scale':
                    t.transform += ' scale(' + u + ')';
                    break;
                  case 'bgy':
                  case 'bgx':
                    t['background-position-' + e[2]] =
                      'calc(' + c + ' + ' + u + 'px)';
                    break;
                  case 'color':
                  case 'backgroundColor':
                  case 'borderColor':
                    var l = b(s, h),
                      d = l[0],
                      p = l[1],
                      f = l[2];
                    t[e] =
                      'rgba(' +
                      d
                        .map(function (t, e) {
                          return (
                            (t += f * (p[e] - t)),
                            3 === e ? m.toFloat(t) : parseInt(t, 10)
                          );
                        })
                        .join(',') +
                      ')';
                    break;
                  case 'blur':
                    t.filter += ' blur(' + (u + (o = o || 'px')) + ')';
                    break;
                  case 'hue':
                    t.filter += ' hue-rotate(' + (u + (o = o || 'deg')) + ')';
                    break;
                  case 'fopacity':
                    t.filter += ' opacity(' + (u + (o = o || '%')) + ')';
                    break;
                  case 'grayscale':
                  case 'invert':
                  case 'saturate':
                  case 'sepia':
                    t.filter += ' ' + e + '(' + (u + (o = o || '%')) + ')';
                    break;
                  default:
                    t[e] = u;
                }
                return t;
              },
              { transform: '', filter: '' }
            );
          },
        },
      },
    ],
    props: { target: String, viewport: Number, easing: Number },
    data: { target: !1, viewport: 1, easing: 1 },
    computed: {
      target: function (t, e) {
        t = t.target;
        return (function t(e) {
          return e ? ('offsetTop' in e ? e : t(m.parent(e))) : document.body;
        })((t && m.query(t, e)) || e);
      },
    },
    update: {
      read: function (t, e) {
        var r,
          i,
          t = t.percent;
        if ((e.has('scroll') || (t = !1), this.matchMedia))
          return (
            (e = t),
            (r = m.scrolledOver(this.target) / (this.viewport || 1)),
            (i = this.easing),
            {
              percent: (t = m.clamp(r * (1 - (i - i * r)))),
              style: e !== t && this.getCss(t),
            }
          );
      },
      write: function (t) {
        t = t.style;
        this.matchMedia ? t && m.css(this.$el, t) : this.reset();
      },
      events: ['scroll', 'resize'],
    },
  };
  return (
    'undefined' != typeof window &&
      window.UIkit &&
      window.UIkit.component('parallax', t),
    t
  );
});
